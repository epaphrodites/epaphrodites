Dipping deeper
 Introduction
 Commandes
 Python
 C
 Twig
 Twig function
 Twig filters
 Users rights
# Introduction
The constant growth in the complexity of computer systems demands adaptive and efficient development tools. The advanced features of the Epaphrodites framework emerge as a solution to this challenge, offering a streamlined and sophisticated approach for seamlessly managing complex environments. This section of the code requires a specific approach, involving native programming and advanced manipulation of the code through the terminal, utilizing power shell for Windows users. The functions and classes needed here stand out for their robustness and higher complexity.

# Commandes
Commands form the backbone of any operational process. They are executed from the terminal or PowerShell, enabling the facilitation of file creation, modification, deletion, and retrieval. Epaphrodites provides a diverse range of commands, yet you have the opportunity to add new ones or tailor existing ones to precisely meet the unique needs of your projects. This flexibility empowers you to optimize your actions and enhance efficiency in managing your data and IT operations.

 Create a new command
To generate a new command, execute this in the terminal or PowerShell. You can also customize the parameters and options according to your specific needs, providing complete flexibility in creating bespoke commands :

php heredia add:cmd 'add:new' newCommand

Following the execution of the previous command, three distinct files will be generated, each containing functions specifically dedicated to precise tasks.

                    
                    

                        
<?php

namespace Epaphrodites\epaphrodites\Console\commands;

use Epaphrodites\epaphrodites\Console\Models\modelnewCommand;

class commdnewCommand extends modelnewCommand{

    protected static $defaultName = 'add:new';
}

                    

                
                    
                    

                        
<?php

namespace Epaphrodites\epaphrodites\Console\Setting;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;

class settingnewCommand extends Command{

    protected function configure(){

        $this->setDescription('Add your command description')
              ->setHelp('This is help.')
              ->addArgument('name', InputArgument::REQUIRED, 'Your argument name ');
    }
}  

                    

                
                    
                    

                        
<?php

namespace Epaphrodites\epaphrodites\Console\Models;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Epaphrodites\epaphrodites\Console\Setting\settingnewCommand;

class modelnewCommand extends settingnewCommand{

/**
     * @param \Symfony\Component\Console\Input\InputInterface $input
     * @param \Symfony\Component\Console\Output\OutputInterface $output
    */
    protected function execute(InputInterface $input, OutputInterface $output)
    {
       # Get console arguments
       $name = $input->getArgument('name');

       // Your actions
     }
}

                    

                
# Python
The flexible architecture adopted by the Epaphrodites framework not only enables the execution of Python scripts alongside the main language, PHP, but also allows for easy adaptation. This versatility grants the freedom to integrate new functionalities and customize execution methods to suit the specific needs of your projects. Moreover, this compatibility between Python and Epaphrodites opens up new possibilities for creating and integrating more comprehensive solutions, thereby offering optimal performance and greater flexibility in application development.

 Add python file
One of the advantages of the Epaphrodites framework is its compatibility with the Python language. To quickly generate a Python file, you can use the following command: heredia add:python. The file will then be saved in the bin/epaphrodites/python/. Use At (@) symbol to distinguish between the folder and the file.

php heredia add:python file_name // Other exemple : php heredia add:python others@file_name

Here is an example of a Python script generated by the previous command. This script is designed to display the following message: Hello welcome to epaphrodites from Python!. With this generated script, you have the possibility to customize and create your own Python functions.

                    
                    

                        
import sys

class hello_world:

    def func_hello_world(self):
        print('Hello welcome to epaphrodites from Python!')

if __name__ == '__main__':
    hello_world_instance = hello_world()
    hello_world_instance.func_hello_world()

                    

                
 Configuration
This is a python file configuration : bin/epaphrodites/python/config/config.json

                    
                    

                        
{
  "hello_world": {
      "script": "hello_world.py",
      "function": "func_hello_world"
  }
}
                        

                    

                
 Using
Here are two methods for using the executePython function that facilitates the execution of Python scripts within the Epaphrodites framework. This function provides increased flexibility in integrating Python scripts, thereby enhancing the power and versatility of the Epaphrodites ecosystem. Additionally, it streamlines the process of integrating custom Python functionalities into your Epaphrodites projects, paving the way for more robust and modular applications.

                    
                    

                        
$python = new \Epaphrodites\epaphrodites\translate\PythonCodesTranslate();

$result = $python->executePython('hello_world' , [] );

/** Or you can use this **/

$result = static::initConfig()['python']->executePython('hello_world', [] );

                    

                
# C
The integration of the C language within the Epaphrodites framework addresses a strategic necessity: to maximize performance for critical operations while preserving the flexibility offered by PHP and Python. With C, Epaphrodites can access low-level system resources, deliver ultra-fast processing (especially for native extensions), reduce CPU load on complex computations, and significantly enhance overall application responsiveness. It also enables the creation of custom, highly optimized modules while ensuring smooth interoperability with the framework’s other languages.
This synergy between C and the Epaphrodites framework not only optimizes performance but also opens up new avenues for advanced functionalities, making it a powerful tool for developers seeking to push the boundaries of their applications.

This command automatically generates the foundational structure required to build a native PHP extension in C. It sets up the necessary folders, boilerplate .c and .h files, a properly configured config.m4, and all essential scaffolding to get started immediately. This ensures a standardized, clean, and maintainable architecture, allowing developers to focus on writing performant C code without worrying about setup complexity.

php heredia add:c your_extension_name // Other exemple : php heredia add:c noella

This will generate the following directory structure inside your Epaphrodites project:

                    epaphrodites/
                        └── cbuild/
                            ├── config/
                            │   └── noella/
                            │       ├── config.m4
                            │       └── noella.h
                            ├── library/
                            ├── extension/
                            │   └── noella.so  (generated after build)
                            ├── cFunctions/
                                └── noella.c
                
With this scaffolding in place, you can immediately begin defining your C functions in noella.c, declare them in noella.h, and compile everything using the provided script. Epaphrodites handles the boilerplate so you can focus on performance, logic, and integration.

 Structure Breakdown

epaphrodites/cFunctions/noella.c
→ Contains the C source code for the noella extension. This is where you define the functions that will be exposed to PHP.
epaphrodites/cbuild/config/noella/config.m4
→ The configuration file used by phpize to prepare the build. It declares the extension name and the source files to include during compilation.
epaphrodites/cbuild/config/noella/noella.h
→ The header file associated with noella.c. It contains function prototypes, constants, and any shared definitions needed across C files.
epaphrodites/cbuild/library/
→ A temporary workspace for compilation. It can also contain symbolic links or other intermediate build files.
epaphrodites/cbuild/extension/noella.so
→ The final compiled binary. This is the native PHP extension you can load via php.ini.
 noella.c
The noella.c file contains the C function that will be executed when the extension is called. Here’s a simple example of a C function that prints a message to the PHP output:
hello_noella is the name of the function that will be called from PHP. You can modify this function to implement your own logic.
Note: The php_printf function is used to print output to the PHP environment. You can replace it with any other C logic you need.
Make sure to include the necessary headers at the top of your C file, such as #include "php.h", to access PHP's API functions.
Here’s a simple example of a C function that prints a message to the PHP output:

                    
                    

                        
PHP_FUNCTION(hello_noella)
{
     php_printf("Hello from Noella extension!\n");
}

                    

                
The PHP_FE macro registers the function, and PHP_FE_END marks the end of the function entries array. The second parameter arginfo_noella_hello refers to the function's argument info structure, which defines how arguments should be handled by the Zend engine.
This array is usually registered in the extension's module entry structure so that PHP knows which functions to expose. Without this mapping, your C function wouldn’t be visible from the PHP side.

                    
                    

                        
static const zend_function_entry noella_functions[]={
     PHP_FE(hello_noella, arginfo_noella_hello)
     PHP_FE_END
}

                    

                
 Build Script (kouadio)
A shell script that automates the entire build process (phpize, ./configure, make, etc.). It also handles placing the .so file in the correct folder and updating the PHP configuration if necessary.
To run the script, navigate to the The root of your project directory in your terminal and execute the following command:.

Before running the script, ensure that you have the necessary permissions. You can do this by executing the following command in your terminal:
Note: The chmod +x command makes the script executable. The sudo command is used to run the script with superuser privileges, which may be necessary for certain operations like installing the extension.
After that, you can run the script using the following command:

chmod +x kouadio

This command will execute the kouadio script, which will handle the entire build process for your C extension. Make sure to run this command from the bin/epaphrodites/cbuild/ directory where the script is located.
Note: The ./ before the script name indicates that the script is located in the current directory. If you are in a different directory, you will need to provide the full path to the script.
After running the script, you should see output indicating the progress of the build process. If everything goes well, you will have a compiled .so file ready for use in your PHP environment.
Here’s how to run the script:
Note: The sudo command is used to run the script with superuser privileges, which may be necessary for certain operations like installing the extension.
After that, you can run the script using the following command:

sudo ./kouadio your_extension_name -g // exemple : sudo ./kouadio noella -g

If your extension is already located in the bin/epaphrodites/cbuild/extension/ directory and you wish to add it to your PHP environment, ensure that the filename exactly matches the name of the compiled .so file.

To load the extension, use the following command or manually add it to your php.ini file:

sudo ./kouadio your_extension_name -i // exemple : sudo ./kouadio noella -i

Once added, the extension will be available for use in your PHP scripts.
You can confirm that the extension has been successfully loaded by running the following command.
This command will list all loaded PHP extensions, including your newly compiled extension. If you see your extension in the list, it means it has been successfully loaded and is ready for use.
Note: The -m option is used to display the list of loaded modules. You can also use the php -i command to get detailed information about your PHP installation, including loaded extensions.
The php.ini file is the primary configuration file for PHP. By declaring your extension in this file, you ensure it is automatically loaded each time PHP starts.
To check if your extension is loaded, you can use the following command:

php -m // or
php -i

 Prerequisites for Compiling a Native PHP Extension
Before compiling a PHP extension written in C, make sure your environment includes the necessary tools:

A C compiler (such as GCC on Linux/macOS or MSVC on Windows)
PHP development headers and tools
The phpize and php-config utilities
phpize prepares the compilation environment by generating the necessary configuration scripts (like configure), and php-config provides information about your PHP installation (compiler flags, extension directories, include paths, etc.).

To check if these tools are installed and ready, simply run the following commands in your terminal:

phpize --version
php-config --version

# Twig
The Epaphrodites framework uses Twig as a client-side template engine, thus providing a clear separation between the front and back-end while offering multiple advantages. Epaphrodites provides methods to customize functions and filters for optimal use and to advance your code. This division between presentation logic and data processing offers a modular structure, promoting application maintenance and scalability. Furthermore, the ability to customize Twig functionalities within Epaphrodites paves the way for a more flexible web development experience tailored to the specific needs of each project.

 Add function
Epaphrodites facilitates the extension of features on the front-end by allowing the seamless integration of custom functions via Twig. By exploring the bin/epaphrodites/Extension/Functions/SetTwigFunctions.php file, you can extend the capabilities according to your specific needs. Make sure to follow best programming practices when adding your features to ensure a smooth integration into your project. Feel free to draw inspiration from the following example :

                    
                    

                        
/**
 * New twig function
 * @return string
*/
public function newTwigFunction():string
{
    echo "new function test";
}

                    

                
This function newTwigFunction will display new function test on the front-end. However, you have the possibility to design functions, whether they are simple or complex, based on the requirements of your project. Next, open the following file: bin/epaphrodites/Extension/Fronts/TwigExtension.php to integrate the function name on the client side. You can choose to keep the same name or refine it to enhance its readability and understanding.

                    
                    

                        
/**
 * @return array
*/
public function getFunctions():array
{
    return 
    [ 
      new TwigFunction('__new_function', [ $this , 'newTwigFunction']), 
    ];
}

                    

                
Here's how the function will be called on the front-end :

{{ __new_function() }}

 Add filters
Twig filters are essential tools for manipulating and formatting data within your templates. In the context of Epaphrodites, please use the following file: bin/epaphrodites/Extension/Filters/SetTwigFilters.php to customize your own filters.

Here is a simple example of a Twig filter that transforms a string into uppercase : The newTwigFilter function will convert all words to uppercase in the front-end. However, you have the opportunity to design functions, whether they are simple or complex, based on the requirements of your project. Next, open the following file: bin/epaphrodites/Extension/Fronts/TwigExtension.php to integrate the function name on the client side. You can choose to keep the same name or enhance it to improve its readability and understanding.

                    
                    

                        
/**
 * New twig filter
 * @param string $input
 * @return string
*/
public function newTwigFilter(string $input):string
{
    return strtoupper($input);
}

                    

                
The newTwigFilter function will convert all words to uppercase in the front-end. However, you have the opportunity to design functions, whether they are simple or complex, based on the requirements of your project. Next, open the following file: bin/epaphrodites/Extension/Fronts/TwigExtension.php to integrate the function name on the client side. You can choose to keep the same name or enhance it to improve its readability and understanding.

                    
                    

                        
/**
 * @return array
*/
public function getFilters():array
{
    return 
    [ 
      new TwigFilter('convertToUpper', [ $this , 'newTwigFilter']), 
    ];
}

                    

                
Here's how the filter will be called on the front-end :

{{ "hello, world!"|convertToUpper }}

# Users rights
Our user rights management system stands out for its robustness, flexibility, and ease of use. By using the heredia add:module command via the bin/epaphrodites/EpaphMozart/ModulesConfig/ListsGetModulesList.php file for modules, and heredia add:right through the bin/epaphrodites/EpaphMozart/ModulesConfig/GetRightList.php file for user lists, you'll experience a balanced and dynamic approach to rights management. These carefully designed files facilitate a dissociated and optimized management, enabling a dynamic adaptation of rights according to evolving needs. However, it's important to customize this system to perfectly fit the specifics of your projects. This customization will ensure seamless integration into your environment, providing optimal security and maximum accessibility for your end users.

 Modules
In the context of the Epaphrodites framework, user rights management is structured through Modules, with each module representing a meaningful grouping. The swift creation of a module is achieved by using the command: heredia add:module. In the following example, we will establish a module with the key key and the label New module. Note well: replace spaces with underscores ( _ ).

php heredia add:module  key  New_module

Here is the outcome of generating the New module with the key key.

                    
                    

                        
/**
 * @return array
*/
public static function GetModuleList():array
{
    return 
    [ 
      'key' => 'NEW MODULE', 
    ];
}

                    

                
 Rights lists
In a modular application, managing user rights is essential for controlling access to specific features. This section explains how to create and activate a user right associated with a specific module.
This is a user rights management system that allows you to create and manage user rights within the Epaphrodites framework. The heredia add:right command is used to quickly generate a user right, which is then linked to the module created earlier. This system provides a flexible and efficient way to manage user permissions, ensuring that users have access only to the resources they need.

In this example, we will generate a user right identified by a unique key, linked to the corresponding module key, and associated with the label label_of_right, located in the users/your_view_path directory.
Executing the appropriate command will activate this right, making it available in the rights management system.
Once activated, it can be selected and assigned through the permission interface, allowing for precise access control across your application.

Note well: replace spaces with underscores _ and At @ symbol to distinguish between the folder and the file.

php heredia add:right key users@your_view_path label_of_right

Here is the result of the rapid generation of a user right using the command :

                    
                    

                        
/**
 * @return array
*/
public static function RightList():array
{
    return 
    [
      [
        'apps' => 'key',
        'libelle' => 'Label of right',
        'path' => 'users/your_view_path'
      ],
    ];
}
